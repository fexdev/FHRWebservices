# Entity Framework Core

Im Folgenden wollen wir uns die Grundlagen des Entity Frameworks ansehen. EF ist ein komplexes Framework, daher k√∂nnen hier nicht alle Funktionen behandelt werden. Ich empfehle die gro√üartige Dokumentation auf https://docs.microsoft.com.

## √úberblick

- Interaktion mit relationalen Datenbanken √ºber ein Objektmodell das direkt die Business-Objekte der Anwendung abbildet
- Object Relational Mapper
- Favorisierte API f√ºr Datenzugriff in .NET
- K√ºmmert sich um den Aufbau und die Ausf√ºhrung von SQL-Statements
- Umwandlung von Abfrageergebnissen in Business-Objekte
- √Ñnderungsverfolgung an Business-Objekten
- LINQ ist Grundbestandteil der Architektur, nicht nachtr√§glich hinzugef√ºgt
- Reduzierte Abh√§ngigkeiten zum physikalischen Datenbankschema und zu relationalen Datenbanken selbst (nur EF Core)
- Hohe Testbarkeit: die Business-Objekte k√∂nnen POCOs sein und enthalten damit keine Datenbankzugriffslogik und auch keine harten Abh√§ngigkeiten zum EF
- Es werden keine Collections aus Zeilen und Spalten bearbeitet, sondern Collections aus typisierten Objekten, sog. Entit√§ten
- Entity Framework kommt in 2 unterschiedlichen Ans√§tzen
  - model-first (nur Full-Framework, EF Core kann aber ein Modell aus der DB generieren)
  - code-first

## Vorteile von OR-Mappern

- Bekanntes Umfeld in der objektorientierten Entwicklung
  - Kenntnisse von SQL, Datenbankschemas nicht zwingend notwendig
  - H√∂here Entwicklungsgeschwindigkeit da die SQL-Tabellen zu einem sp√§teren Zeitpunkt generiert werden k√∂nnen (In-Memory-Database)
- Automatische √Ñnderungserkennung an Objekten und Generierung von SQL f√ºr das Update
- Abstraktion von der zugrundeliegenden Datenbank-Technologie
  - MS SQL
  - Postgres
  - SQLite
  - MySQL

## Nachteile von OR-Mappern

- Queries k√∂nnen inperformant werden (n+1 Problem)
- Insgesamt ist die Performance relativ gesehen zur direkten Implementierung langsamer (high-traffic)

## EF Core im Projekt verwenden

Auch EF Core besteht aus einer Reihe von `Nuget`-Paketen welche im Projekt eingebunden werden m√ºssen. Dabei trennen sich die Pakete in die abstrakte Hauptimplementierung von EF Core `Microsoft.EntityFrameworkCore` und sog. Provider.
Pro Datenbank ben√∂tigt EF Core einen Provider, welche die Kommunikation mit der Datenbank zur Ausf√ºhrung der Befehle steuert. Es gibt eine Vielzahl von offiziellen und 3rd Party Providern f√ºr EF Core.

- `Microsoft.EntityFrameworkCore.InMemory`
- `Microsoft.EntityFrameworkCore.SqlLite`
- `Microsoft.EntityFrameworkCore.SqlServer`
- `Npgsql.EntityFrameworkCore.PostgreSQL`

Mindestens ein Provider muss installiert werden.

## EF Core Building Blocks

Der Einsatz von EF Core im Projekt kann in folgende Bereiche aufgeteilt werden:

- DbContext und Entit√§ten modellieren
- DbContext im Dependency Injection System konfigurieren und registrieren
  - Datenprovider ausw√§hlen => MS SQLServer, PostgresSQL, Sqlite‚Ä¶
- Migrationen f√ºr das Datenmodell generieren
- Migrationen auf die Datenbank anwenden

### DbContext und Entit√§ten modellieren

Entit√§ten mit ihren Eigenschaften und Relationen werden bei EF Core als POCOs (Plain Old C# Objects) modelliert, d.h. sie m√ºssen nicht von einer Basisklasse abgeleitet worden sein oder ein spezielles Interface implementieren. √úber Attribute kann zus√§tzliche Funktionalit√§t wie Validierung oder datenbankspezifische Einstellungen wie Spaltenname konfiguriert werden. Will man auch keine Attribute haben (h√§ufig bei Domain Driven Design), so kann diese Konfiguration √ºber spezielle Klassen gel√∂st werden.

Hier die `Author`-Entit√§t als Beispiel.

```csharp
public class Author
{
    // üëá Sollen Ids nicht automatisch erzeugt werden, kann dieses Attribute dies verhindern.
    // Standardm√§√üig wird eine Identity-Spalte mit Autoincrement in der DB angelegt.
    [DatabaseGenerated(DatabaseGeneratedOption.None)]
    public int Id { get; set; }

    // üëá Validierungsattribute k√∂nnen verwendet werden, um die Konsistenz der Daten sicherzustellen.
    [Required]
    [MaxLength(255)]
    public string FirstName { get; set; }

    [Required]
    [MaxLength(255)]
    public string LastName { get; set; }

    [Range(0, 150)]
    public int Age { get; set; }

    // üëá Relationen werden unterst√ºtzt, komplizierte F√§lle wie many-to-many (Books) m√ºssen aber noch im DbContext nachkonfiguriert werden
    public ICollection<ContactInfo> ContactInfos { get; set; }
    public ICollection<BookAuthorRel> Books { get; set; }
}
```

Der `DbContext` ist die zentrale Stelle welche die Entit√§ten zusammenfasst und als Einstiegspunkt in die Verwendung der EF Core API bietet.

- Einstiegspunkt f√ºr das EF um das Objektmodell verwalten zu k√∂nnen und damit zu arbeiten
- Entit√§ten die direkt abgefragt und verarbeitet werden sollten in DbSet<TEntity>-Properties ver√∂ffentlicht werden
- √úber den Context kann das Modell vor der ersten Verwendung konfiguriert werden
- Der Context bietet Lifecycle-Hooks wie SaveChanges() und ShouldValidateEntity() die √ºberschrieben werden k√∂nnen
- √úber den Context wird auch der zu verwendende Data Provider konfiguriert (meist in .config, .json)
- √úber den Context kann auf den Change Tracker zugegriffen werden, welcher √Ñnderungen an den Entit√§ten aufzeichnet
- √úber SaveChanges() werden die √Ñnderungen in der DB persistiert
- Enth√§lt einen Cache f√ºr bereits geladene Entit√§ten
  - Daher sollten Entit√§ten nicht am EF vorbei modifiziert werden

Hier ein Beispiel f√ºr den `DbContext`:

```csharp
public class BookDbContext : DbContext
{
    // Die Options enthalten Informationen f√ºr die DB-Connection mit der das EF-Framework
    // auf die DB zugreifen soll
    public BookDbContext(DbContextOptions<BookDbContext> options)
        : base(options)
    {
    }

    // Die Entit√§ten die direkt abgefragt werden k√∂nnen sollen,
    // werden √ºber DbSets angegeben. Es m√ºssen nicht alle Entit√§ten
    // angegeben werden
    public DbSet<Book> Books { get; set; }
    public DbSet<Author> Authors { get; set; }

    // Hier k√∂nnen noch Konfigurationen an Entit√§ten
    // und Conventions durchgef√ºhrt werden, bevor
    // das Modell benutzbar ist
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        //                                                        üëá EF versucht automatisch den passenden Datentypen f√ºr die Tabellenspalte zu erkennen, dies kann hier festgelegt werden.
        modelBuilder.Entity<Book>().Property(b => b.ReleaseDate).HasColumnType("datetime2");

        // m:n Relationen k√∂nnen aktuell von EF nicht automatisch erkannt werden
        // Daher muss die Beziehung manuell definiert werden und eine Zwischentabelle f√ºr das Mapping
        // angelegt werden
        modelBuilder.Entity<BookAuthorRel>()
            .HasKey(t => new { t.BookId, t.AuthorId }); // üëà Definition eines zusammengesetzten Schl√ºssels (Composite-Key)

        modelBuilder.Entity<BookAuthorRel>()
            .HasOne(pt => pt.Book)
            .WithMany(p => p.Authors)
            .HasForeignKey(pt => pt.BookId);

        modelBuilder.Entity<BookAuthorRel>()
            .HasOne(pt => pt.Author)
            .WithMany(t => t.Books)
            .HasForeignKey(pt => pt.AuthorId);

    }
}
```

EF Core hat eine vielzahl von Konventionen die automatisch angewendet werden um m√∂glichst wenig zus√§tzliche Konfiguration erstellen zu m√ºssen.
√úber Attribute in den Entit√§ten und / oder in `OnModelCreating()` kann das Modell und die angewendeten Konventionen nach Bedarf ge√§ndert werden.

√úber `EntityConfiguration` kann verhindert werden, dass `OnModelCreating()` zu un√ºbersichtlich wird.

```csharp
public class Book
{
    public int Id { get; set; }
    public string Title { get; set; }
    public string Isbn { get; set; }
    public DateTime ReleaseDate { get; set; }
    public ICollection<BookAuthorRel> Authors { get; set; }
}
```

```csharp
public class BookConfiguration : IEntityTypeConfiguration<Book>
{
    public void Configure(EntityTypeBuilder<Book> builder)
    {
        builder.Property(b => b.Isbn).IsRequired();
        builder.Property(b => b.Title).IsRequired().HasMaxLength(500);
    }
}
```

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    // ...

    //üëá die Konfiguration kann auch in eigene Klassen ausgelagert werden
    modelBuilder.ApplyConfiguration(new BookConfiguration());
}
```

## Alternativen

EF Core ist nicht der einzige OR-Mapper f√ºr .Net Core. Bekannte Alternativen sind `NHibernate` und `Dapper`.
`Dapper`ist dabei besonders schlank designt und hat deutlich weniger OR-Mapper Features, im Gegenzug ist es in einigen F√§llen erheblich performanter.

### Dapper

- Erfunden und gepflegt von den StackOverflow-Betreibern
- D√ºnner Layer √ºber ADO.NET (SQL-Connections)
- Weniger Abstraktion als EF Core, daf√ºr aber deutlich h√∂here Performance
- Trotzdem den Vorteil des Objekt-Mappings
- https://github.com/StackExchange/Dapper
- Kein Konzept von ‚ÄûMigrationen‚Äú wie bei EF Core
